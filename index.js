//------------------------------------------------------------------------------------------------------------
//User Editable Configurable Value
//Below are four variables you can edit to easily customize the script.
const runOnlyOnce = true; // set to true to run the script one time only and then exit

const intervalDays = 90; // set the number of days between script runs if runOnlyOnce is false

const daysSinceLastActive = 90; //seats will be given to users who have been since the last X days. 

const batchCount = 50; // the number of users that will be retrieved with each call. The default value is 50. We recommend not increasing this number (to avoid rate limiting)

const testRun = true // if this value is set to true, the script will simulate giving seats to active members but will not actually give them seats. Set to false if you would like to actually give users enterprise seats. 


//------------------------------------------------------------------------------------------------------------
//REQUIRED authintication credentials
//These are the credentials required to authenticate with the the Trello API. 

const apiKey = 'YOURAPIKEY'; //Enter your personal API key
const apiToken = 'YOURAPITOKEN'; //Enter your personal API token that was generated by the API key above
const enterpriseId = 'YOURENTERPRISEID'; //Enter the ID of the Trello Enterprise you want to add members to.

//------------------------------------------------------------------------------------------------------------
//Below this line is the main execution code. Edits below this line are not recommended unless you are trying to adapt the core funtionality of the script.

const headers = { 'Accept': 'application/json' };
const request = require('request');
const moment = require('moment');
const process = require('process');
const fs = require('fs');
const parse = require('csv-parse');
const timestamp = moment().format("YYYY-MM-DD-HHmmss")
let pulledBatches = 0; 
const MAX_RETRIES = 3
const RETRY_DELAY = 1000; 

// Helper function to handle retries. Set to retry 3 times with a 1000 ms delay between retries. 
async function withRetry(fn, maxRetries) {
  let attempts = 0;
  let error;

  while (attempts <= maxRetries) {
      try {
          return await fn();
      } catch (err) {
          error = err;
          attempts++;
          if (attempts <= maxRetries) {
              await new Promise(res => setTimeout(res, RETRY_DELAY));
          }
      }
  }

  throw error;
}

// Function to put together pre-report and then kickoff functions to give/reactivate eligiable users. 
function putTogetherReport() {
  //creates csv file where where report will be test/pre run user report will be stored 
  const csvHeaders = [['Member Email', 'Member ID', 'Member Full Name', 'Days Since Last Active', 'Last Active', 'Currently Deactivated', 'Eligible For Enterprise Seat']];
  fs.writeFileSync(`pre_run_member_report_${timestamp}.csv`, '');
  csvHeaders.forEach((header) => {
    fs.appendFileSync(`pre_run_member_report_${timestamp}.csv`, header.join(', ') + '\r\n');
  });

  // API endpoint to get list of Free Members
  let getManagedMembersUrl = `https://api.trello.com/1/enterprises/${enterpriseId}/members?fields=idEnterprisesDeactivated,fullName,aaId,memberEmail,username,dateLastAccessed&associationTypes=managedFree&key=${apiKey}&token=${apiToken}&count=${batchCount}}`;

  // Function to pull the next set of users 
  async function processNextBatch(startIndex) {
    return new Promise(async (resolve, reject) => {
        const getNextBatchUrl = `${getManagedMembersUrl}&startIndex=${startIndex}`;

        const requestFn = () => new Promise((innerResolve, innerReject) => {
            request.get({
                url: getNextBatchUrl,
                headers,
                json: true
            }, async (error, response, body) => {
                if (error) {
                    return innerReject(error);
                }

                if (response && response.statusCode !== 200) {
                    return innerReject(new Error(body || `HTTP Error: ${response.statusCode}`));
                }

                const membersResponse = body;
                pulledBatches = pulledBatches + 1;
                console.log(`Pulled batch #${pulledBatches} with ${membersResponse.length} members. Adding them to the list of users...`);

                if (!Array.isArray(membersResponse) || membersResponse.length === 0) {
                    if (testRun === false) {
                        console.log(`All members have been added to the report. See member_report_${timestamp}.csv in your directory. Now going to start giving active users Enterprise licenses...`);
                        
                        await beginGivingSeats();
                    } else {
                        console.log(`Test run complete! All members have been added to the report. See member_report_${timestamp}.csv in your directory`);
                    }
                    innerResolve();
                    return;
                }

                membersResponse.forEach((member) => {
                    const daysActive = moment().diff(moment(member.dateLastAccessed), 'days');
                    let eligible = "";
                    let deactivated = "";
                    if (member.idEnterprisesDeactivated.length > 0) {
                        deactivated = "True";
                    } else {
                        deactivated = "False";
                    }
                    if (daysActive < daysSinceLastActive) {
                        eligible = "Yes";
                    } else {
                        eligible = "No";
                    }
                    const rowData = [member.memberEmail, member.id, member.fullName, daysActive, member.dateLastAccessed, deactivated, eligible, member.aaId];
                    fs.appendFileSync(`pre_run_member_report_${timestamp}.csv`, rowData.join(', ') + '\r\n');
                });

                // process next batch recursively
                await processNextBatch(startIndex + batchCount);
                innerResolve();
            });
        });

        try {
            await withRetry(requestFn, MAX_RETRIES);
            resolve();
        } catch (err) {
            console.error(`Failed to process batch starting from index ${startIndex} after ${MAX_RETRIES} retries. Error: ${err.message}`);
            reject(err);
        }
    });
}

processNextBatch(1);

}
              
// Function that actually gives eligiable users an enterprise seat or re-activates them. 
async function beginGivingSeats() {
  const post_timestamp = moment().format("YYYY-MM-DD-HHmmss");
  
  const post_csvHeaders = [['Member Email', 'Member ID', 'Member Full Name', 'Days Since Last Active', 'Last Active', 'Eligible For Enterprise Seat', 'Given Enterprise Seat']];
  let pre_rows; 
  try {
      fs.writeFileSync(`post_run_member_report_${post_timestamp}.csv`, '');
      post_csvHeaders.forEach((header) => {
          fs.appendFileSync(`post_run_member_report_${post_timestamp}.csv`, header.join(', ') + '\r\n');
      });
      
      const pre_csvData = fs.readFileSync(`pre_run_member_report_${timestamp}.csv`, "utf-8");
      pre_rows = pre_csvData.trim().split(/\r?\n/);
  } catch (err) {
      console.error('Error while reading or writing CSV:', err);
      throw err;
  }

  const apiRequests = pre_rows.map((pre_row, i) => {
      return new Promise(async (resolve, reject) => {
          const cols = pre_row.split(",");
          const email = cols[0];
          const memberId = cols[1].trim();
          const daysActive = parseInt(cols[3]);
          const fullName = cols[2];
          const lastAccessed = cols[4];
          const isDeactivated = cols[5].trim();
          const isEligible = cols[6].trim();

          const requestFn = () => new Promise((resolve, reject) => {
              if (isEligible === "Yes" && isDeactivated === "False") {
                  const giveEnterpriseSeatUrl = `https://api.trello.com/1/enterprises/${enterpriseId}/members/${memberId}/licensed?key=${apiKey}&token=${apiToken}&value=true`;
                  const data = { memberId: memberId };

                  request.put({
                      url: giveEnterpriseSeatUrl,
                      headers: headers,
                      form: data,
                  }, (error, response, body) => {
                      if (error) {
                          return reject(error);
                      }

                      if (response.statusCode === 200) {
                          const rowData = [email, memberId, fullName, daysActive, lastAccessed, isEligible, 'Yes'];
                          fs.appendFileSync(`post_run_member_report_${post_timestamp}.csv`, rowData.join(', ') + '\r\n');
                          console.log(`Gave Enterprise seat to member: ${fullName} with email ${email}`)
                          resolve();
                      } else {
                          reject(new Error(body || `HTTP Error: ${response.statusCode}`));
                      }
                  });
              } else if (isEligible === "Yes" && isDeactivated === "True") {
                  const reActivateUser = `https://api.trello.com/1/enterprises/${enterpriseId}/members/${memberId}/deactivated?key=${apiKey}&token=${apiToken}&value=false`;
                  const data = { memberId: memberId };

                  request.put({
                      url: reActivateUser,
                      headers: headers,
                      form: data,
                  }, (error, response, body) => {
                      if (error) {
                          return reject(error);
                      }

                      if (response.statusCode === 200) {
                          const rowData = [email, memberId, fullName, daysActive, lastAccessed, isEligible, 'Yes'];
                          fs.appendFileSync(`post_run_member_report_${post_timestamp}.csv`, rowData.join(', ') + '\r\n');
                          console.log(`Reactivated and gave seat to member: ${fullName} with email ${email}`);
                          resolve();
                      } else {
                          reject(new Error(body || `HTTP Error: ${response.statusCode}`));
                      }
                  });
              } else if (email === "Member Email") {
                  resolve();
              } else {
                  const rowData = [email, memberId, fullName, daysActive, lastAccessed, isEligible, 'No'];
                  fs.appendFileSync(`post_run_member_report_${post_timestamp}.csv`, rowData.join(', ') + '\r\n');
                  resolve();
              }
          });

          try {
              await withRetry(requestFn, MAX_RETRIES);
          } catch (err) {
              console.error(`Failed to process ${email} after ${MAX_RETRIES} retries. Error: ${err.message}`);
          }

          resolve();
      });
  });

  try {
      await Promise.all(apiRequests);
      console.log(`All done! Gave Enterprise seats to all active users! You can find the results in post_run_member_report_${post_timestamp}.csv.`);
  } catch (err) {
      console.error('Some errors occurred while processing members:', err);
  }
};

// run the job once if runOnlyOnce is true, otherwise schedule it to run every X days
if (runOnlyOnce) {
  console.log('Running bulk licensing script one time only.');
  putTogetherReport();

} else {
  console.log(`Running bulk licensing script automatically every ${intervalDays} days`);
  cron.schedule(`0 0 1 */${intervalDays} * *`, () => {
    console.log(`Running bulk licensing script automatically every ${intervalDays} days`);
    putTogetherReport();
  });
  // run the job once on startup
  putTogetherReport();
}

